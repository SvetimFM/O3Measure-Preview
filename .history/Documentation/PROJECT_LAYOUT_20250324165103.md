# O3Measure Project Layout

## Technology Stack

The O3Measure application is built using the following technology stack:

- **React** - UI components and application structure
- **Three.js** - 3D graphics and rendering
- **@react-three/fiber** - React renderer for Three.js
- **@react-three/xr** - React components for WebXR
- **Node.js** - Package management and build tooling
- **Vite** - Development server and build system

This stack allows us to:
- Leverage React's component model for UI and 3D elements
- Build WebXR experiences that run on Meta Quest devices
- Create a maintainable and scalable codebase

## Component Analysis

The main components in our application are:

1. **State Management** - React state hooks and context
2. **Three.js Scene Setup** - React components wrapping Three.js objects
3. **WebXR Setup** - ARCanvas and XR components from @react-three/xr
4. **Controller/Hand Tracking** - Controller components and hooks for input
5. **UI Components** - React components for panels, buttons, text
6. **Workflow Steps** - Component-based step implementation
7. **Visualization Components** - Wall plane, object projection, markers
8. **Utility Functions** - Math calculations, geometry helpers

## Project Structure

```
/src
  /assets
    /textures
    /models
    /fonts
  
  /components
    /three               # Three.js specific components
      /markers
        WallMarker.jsx
        ObjectMarker.jsx
        AnchorMarker.jsx
      /visualizations
        WallProjection.jsx
        ObjectProjection.jsx
        GridHelper.jsx
      /controllers
        ControllerRay.jsx
        Crosshair.jsx
        HandModel.jsx
    
    /ui                  # 2D UI components using DOM overlay
      Panel.jsx
      Button.jsx
      Text.jsx
      StepIndicator.jsx
  
  /hooks                 # Custom React hooks
    useControllerInput.js
    useHandTracking.js
    useRaycast.js
    useMeasurement.js
    useSteps.js
  
  /features
    /itemHanging         # Main feature components
      ItemHangingApp.jsx   # Main component for the feature
      /steps
        WallSelection.jsx
        ObjectDefinition.jsx
        AnchorPoints.jsx
        Projection.jsx
  
  /context               # React context for state management
    AppStateContext.jsx
    XRContext.jsx
  
  /utils
    geometry.js
    math.js
    materials.js         # Material definitions/factories
    three-utils.js       # Three.js helper functions
    xr-utils.js          # WebXR helper functions
  
  /constants
    colors.js
    sizes.js
    steps.js
  
  App.jsx                # Main app component with ARCanvas
  index.jsx              # Entry point
```

## Key Design Patterns

1. **Component-Based Architecture**: Both UI and 3D elements are implemented as React components

2. **Feature-Oriented Organization**: Code is organized primarily by feature domains rather than technical layers

3. **React Hooks for Logic**: Reusable logic is encapsulated in custom hooks

4. **Context for State Management**: Global application state is managed through React Context

5. **Declarative 3D Rendering**: Three.js objects are rendered declaratively using react-three-fiber's JSX syntax

## Implementation Examples

### Main Application Component

```jsx
// App.jsx
import { ARCanvas } from '@react-three/xr'
import { ItemHangingApp } from './features/itemHanging/ItemHangingApp'
import { AppStateProvider } from './context/AppStateContext'

export function App() {
  return (
    <AppStateProvider>
      <ARCanvas
        sessioninit={{ 
          requiredFeatures: ['hit-test', 'hand-tracking'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.getElementById('ui-overlay') }
        }}
      >
        <ambientLight intensity={0.8} />
        <ItemHangingApp />
      </ARCanvas>
    </AppStateProvider>
  )
}
```

### Feature Component Example

```jsx
// features/itemHanging/ItemHangingApp.jsx
import { XR, Controllers } from '@react-three/xr'
import { useState } from 'react'
import { WallSelection } from './steps/WallSelection'
import { ObjectDefinition } from './steps/ObjectDefinition'
import { AnchorPoints } from './steps/AnchorPoints'
import { Projection } from './steps/Projection'

export function ItemHangingApp() {
  const [currentStep, setCurrentStep] = useState(0)
  const [wallPoints, setWallPoints] = useState([])
  const [objectPoints, setObjectPoints] = useState([])
  const [anchorPoints, setAnchorPoints] = useState([])
  
  const nextStep = () => setCurrentStep(prev => Math.min(prev + 1, 3))
  const resetStep = () => {
    // Reset logic for current step
  }
  
  return (
    <XR>
      <Controllers />
      
      {/* Render the current step component */}
      {currentStep === 0 && (
        <WallSelection 
          wallPoints={wallPoints}
          setWallPoints={setWallPoints}
          onNext={nextStep}
          onReset={resetStep}
        />
      )}
      {/* Additional steps */}
    </XR>
  )
}
```

### Custom Hook Example

```jsx
// hooks/useControllerInput.js
import { useController } from '@react-three/xr'
import { useEffect, useCallback } from 'react'

export function useControllerInput(hand = 'right', { onSelect, onSelectEnd } = {}) {
  const controller = useController(hand)
  
  const handleSelect = useCallback((event) => {
    if (onSelect) onSelect(event)
  }, [onSelect])
  
  const handleSelectEnd = useCallback((event) => {
    if (onSelectEnd) onSelectEnd(event)
  }, [onSelectEnd])
  
  useEffect(() => {
    if (controller) {
      controller.controller.addEventListener('selectstart', handleSelect)
      controller.controller.addEventListener('selectend', handleSelectEnd)
      
      return () => {
        controller.controller.removeEventListener('selectstart', handleSelect)
        controller.controller.removeEventListener('selectend', handleSelectEnd)
      }
    }
  }, [controller, handleSelect, handleSelectEnd])
  
  return controller
}
```

## Development Workflow

1. Development is done using the Vite development server with HTTPS enabled
2. Testing on Meta Quest requires connecting to the development server over LAN
3. Component development follows a bottom-up approach, starting with basic elements
4. Features are developed step-by-step, matching the user workflow

## Prerequisites for Running the Project

- Node.js 16+ 
- Meta Quest browser with WebXR support
- Local HTTPS development environment for WebXR